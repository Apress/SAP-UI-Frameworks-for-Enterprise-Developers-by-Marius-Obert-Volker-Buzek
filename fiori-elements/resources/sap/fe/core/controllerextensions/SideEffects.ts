import Log from "sap/base/Log";
import type {
	ControlSideEffectsType,
	ODataSideEffectsType,
	SideEffectsService,
	SideEffectsTarget,
	SideEffectsType
} from "sap/fe/core/services/SideEffectsServiceFactory";
import type Event from "sap/ui/base/Event";
import type Control from "sap/ui/core/Control";
import ControllerExtension from "sap/ui/core/mvc/ControllerExtension";
import type View from "sap/ui/core/mvc/View";
import Context from "sap/ui/model/odata/v4/Context";
import ODataMetaModel from "sap/ui/model/odata/v4/ODataMetaModel";
import CommonUtils from "../CommonUtils";
import { BaseManifestSettings } from "../converters/ManifestSettings";
import { defineUI5Class, finalExtension, methodOverride, privateExtension, publicExtension } from "../helpers/ClassSupport";
import PageController from "../PageController";

type BaseSideEffectPropertyType = {
	name: string;
	immediate?: boolean;
	sideEffects: SideEffectsType;
};

export type MassEditFieldSideEffectPropertyType = BaseSideEffectPropertyType;

export type FieldSideEffectPropertyType = BaseSideEffectPropertyType & {
	context: Context;
};

export type FieldSideEffectDictionary = Record<string, FieldSideEffectPropertyType>;

export type MassEditFieldSideEffectDictionary = Record<string, MassEditFieldSideEffectPropertyType>;

type FailedSideEffectDictionary = Record<string, SideEffectsType[]>;

export type FieldGroupSideEffectType = {
	promise: Promise<any>;
	sideEffectProperty: FieldSideEffectPropertyType;
};

const IMMEDIATE_REQUEST = "$$ImmediateRequest";
@defineUI5Class("sap.fe.core.controllerextensions.SideEffects")
class SideEffectsControllerExtension extends ControllerExtension {
	protected base!: PageController;

	private _view!: View;

	private _registeredFieldGroupMap!: Record<string, FieldGroupSideEffectType>;

	private _fieldGroupInvalidity!: Record<string, Record<string, boolean>>;

	private _sideEffectsService!: SideEffectsService;

	private _registeredFailedSideEffects!: FailedSideEffectDictionary;

	@methodOverride()
	onInit() {
		this._view = this.base.getView();
		this._sideEffectsService = CommonUtils.getAppComponent(this._view).getSideEffectsService();
		this._registeredFieldGroupMap = {};
		this._fieldGroupInvalidity = {};
		this._registeredFailedSideEffects = {};
	}

	/**
	 * Adds a SideEffects control.
	 *
	 * @function
	 * @name addControlSideEffects
	 * @param entityType Name of the entity where the SideEffects control will be registered
	 * @param controlSideEffects SideEffects to register. Ensure the sourceControlId matches the associated SAPUI5 control ID.
	 */
	@publicExtension()
	@finalExtension()
	addControlSideEffects(entityType: string, controlSideEffects: Omit<ControlSideEffectsType, "fullyQualifiedName">): void {
		this._sideEffectsService.addControlSideEffects(entityType, controlSideEffects);
	}

	/**
	 * Removes SideEffects created by a control.
	 *
	 * @function
	 * @name removeControlSideEffects
	 * @param control SAPUI5 Control
	 */
	@publicExtension()
	@finalExtension()
	removeControlSideEffects(control: Control): void {
		const controlId = control.isA?.("sap.ui.base.ManagedObject") && control.getId();

		if (controlId) {
			this._sideEffectsService.removeControlSideEffects(controlId);
		}
	}

	/**
	 * Gets the appropriate context on which SideEffects can be requested.
	 * The correct one must have the binding parameter $$patchWithoutSideEffects.
	 *
	 * @function
	 * @name getContextForSideEffects
	 * @param bindingContext Initial binding context
	 * @param sideEffectEntityType EntityType of the sideEffects
	 * @returns SAPUI5 Context or undefined
	 */
	@publicExtension()
	@finalExtension()
	getContextForSideEffects(bindingContext: any, sideEffectEntityType: string): Context | undefined {
		let contextForSideEffects = bindingContext,
			entityType = this._sideEffectsService.getEntityTypeFromContext(bindingContext);

		if (sideEffectEntityType !== entityType) {
			contextForSideEffects = bindingContext.getBinding().getContext();
			if (contextForSideEffects) {
				entityType = this._sideEffectsService.getEntityTypeFromContext(contextForSideEffects);
				if (sideEffectEntityType !== entityType) {
					contextForSideEffects = contextForSideEffects.getBinding().getContext();
					if (contextForSideEffects) {
						entityType = this._sideEffectsService.getEntityTypeFromContext(contextForSideEffects);
						if (sideEffectEntityType !== entityType) {
							return undefined;
						}
					}
				}
			}
		}

		return contextForSideEffects || undefined;
	}

	/**
	 * Gets the SideEffects map for a field
	 * These SideEffects are
	 * - listed into FieldGroupIds (coming from an OData Service)
	 * - generated by a control or controls and that configure this field as SourceProperties.
	 *
	 * @function
	 * @name getFieldSideEffectsMap
	 * @param field Field control
	 * @returns SideEffects map
	 */
	@publicExtension()
	@finalExtension()
	getFieldSideEffectsMap(field: Control): FieldSideEffectDictionary {
		let sideEffectsMap: FieldSideEffectDictionary = {};
		const fieldGroupIds = field.getFieldGroupIds(),
			viewEntitySetSetName = (this._view.getViewData() as BaseManifestSettings).entitySet,
			viewEntitySet = this._sideEffectsService.getConvertedMetaModel().entitySets.find((entitySet) => {
				return entitySet.name === viewEntitySetSetName;
			});

		// SideEffects coming from an OData Service
		sideEffectsMap = this.getSideEffectsMapForFieldGroups(
			fieldGroupIds,
			field.getBindingContext() as Context | null | undefined
		) as FieldSideEffectDictionary;

		// SideEffects coming from control(s)
		if (viewEntitySetSetName && viewEntitySet) {
			const viewEntityType = viewEntitySet.entityType.fullyQualifiedName,
				fieldPath = this.getTargetProperty(field),
				context = this.getContextForSideEffects(field.getBindingContext(), viewEntityType);

			if (fieldPath && context) {
				const controlSideEffectsEntityType = this._sideEffectsService.getControlEntitySideEffects(viewEntityType);
				Object.keys(controlSideEffectsEntityType).forEach((sideEffectsName) => {
					const oControlSideEffects = controlSideEffectsEntityType[sideEffectsName];
					if (oControlSideEffects.sourceProperties.includes(fieldPath)) {
						const name = `${sideEffectsName}::${viewEntityType}`;
						sideEffectsMap[name] = {
							name: name,
							immediate: true,
							sideEffects: oControlSideEffects,
							context: context
						};
					}
				});
			}
		}
		return sideEffectsMap;
	}

	/**
	 * Gets the sideEffects map for fieldGroups.
	 *
	 * @function
	 * @name getSideEffectsMapForFieldGroups
	 * @param fieldGroupIds Field group ids
	 * @param fieldContext Field binding context
	 * @returns SideEffects map
	 */

	@publicExtension()
	@finalExtension()
	getSideEffectsMapForFieldGroups(
		fieldGroupIds: string[],
		fieldContext?: Context | null
	): MassEditFieldSideEffectDictionary | FieldSideEffectDictionary {
		const mSideEffectsMap: MassEditFieldSideEffectDictionary | FieldSideEffectDictionary = {};
		fieldGroupIds.forEach((fieldGroupId) => {
			const { name, immediate, sideEffects, sideEffectEntityType } = this._getSideEffectsPropertyForFieldGroup(fieldGroupId);
			const oContext = fieldContext ? (this.getContextForSideEffects(fieldContext, sideEffectEntityType) as Context) : undefined;
			if (sideEffects && (!fieldContext || (fieldContext && oContext))) {
				mSideEffectsMap[name] = {
					name,
					immediate,
					sideEffects
				};
				if (fieldContext) {
					(mSideEffectsMap[name] as FieldSideEffectPropertyType).context = oContext!;
				}
			}
		});
		return mSideEffectsMap;
	}

	/**
	 * Clear recorded validation status for all properties.
	 *
	 * @function
	 * @name clearFieldGroupsValidity
	 */
	@publicExtension()
	@finalExtension()
	clearFieldGroupsValidity(): void {
		this._fieldGroupInvalidity = {};
	}

	/**
	 * Clear recorded validation status for all properties.
	 *
	 * @function
	 * @name isFieldGroupValid
	 * @param fieldGroupId Field group id
	 * @param context Context
	 * @returns SAPUI5 Context or undefined
	 */
	@publicExtension()
	@finalExtension()
	isFieldGroupValid(fieldGroupId: string, context: Context): boolean {
		const id = this._getFieldGroupIndex(fieldGroupId, context);
		return Object.keys(this._fieldGroupInvalidity[id] ?? {}).length === 0;
	}

	/**
	 * Gets the relative target property related to the Field.
	 *
	 * @function
	 * @name getTargetProperty
	 * @param field Field control
	 * @returns Relative target property
	 */
	@publicExtension()
	@finalExtension()
	getTargetProperty(field: Control): string | undefined {
		const fieldPath = field.data("sourcePath") as string;
		const metaModel = this._view.getModel().getMetaModel() as ODataMetaModel;
		const viewBindingPath = this._view.getBindingContext()?.getPath();
		const viewMetaModelPath = viewBindingPath ? `${metaModel.getMetaPath(viewBindingPath)}/` : "";
		return fieldPath?.replace(viewMetaModelPath, "");
	}

	/**
	 * Manages the workflow for SideEffects with related changes to a field
	 * The following scenarios are managed:
	 *  - Execute: triggers immediate SideEffects requests if the promise for the field event is fulfilled
	 *  - Register: caches deferred SideEffects that will be executed when the FieldGroup is unfocused.
	 *
	 * @function
	 * @name handleFieldChange
	 * @param event SAPUI5 event that comes from a field change
	 * @param fieldValidity
	 * @param fieldGroupPreRequisite Promise to be fulfilled before executing deferred SideEffects
	 * @returns  Promise on SideEffects request(s)
	 */
	@publicExtension()
	@finalExtension()
	async handleFieldChange(event: Event, fieldValidity: boolean, fieldGroupPreRequisite?: Promise<any>): Promise<void> {
		const field = event.getSource() as Control;
		this._saveFieldPropertiesStatus(field, fieldValidity);
		if (!fieldValidity) {
			return;
		}

		try {
			await (event.getParameter("promise") ?? Promise.resolve());
		} catch (e) {
			Log.debug("Prerequisites on Field for the SideEffects have been rejected", e as string);
			return;
		}
		return this._manageSideEffectsFromField(field, fieldGroupPreRequisite ?? Promise.resolve());
	}

	/**
	 * Manages SideEffects with a related 'focus out' to a field group.
	 *
	 * @function
	 * @name handleFieldGroupChange
	 * @param event SAPUI5 Event
	 * @returns Promise returning true if the SideEffects have been successfully executed
	 */
	@publicExtension()
	@finalExtension()
	handleFieldGroupChange(event: Event): Promise<void | void[]> {
		const field = event.getSource() as Control,
			fieldGroupIds: string[] = event.getParameter("fieldGroupIds"),
			fieldGroupsSideEffects = fieldGroupIds.reduce((results: FieldGroupSideEffectType[], fieldGroupId) => {
				return results.concat(this.getRegisteredSideEffectsForFieldGroup(fieldGroupId));
			}, []);

		return Promise.all(
			fieldGroupsSideEffects.map((fieldGroupSideEffects) => {
				return this._requestFieldGroupSideEffects(fieldGroupSideEffects);
			})
		).catch((error) => {
			const contextPath = field.getBindingContext()?.getPath();
			Log.debug(`Error while processing FieldGroup SideEffects on context ${contextPath}`, error);
		});
	}

	/**
	 * Request SideEffects on a specific context.
	 *
	 * @function
	 * @name requestSideEffects
	 * @param sideEffects SideEffects to be executed
	 * @param context Context where SideEffects need to be executed
	 * @param groupId
	 * @param fnGetTargets The callback function which will give us the targets and actions if it was coming through some specific handling.
	 * @returns SideEffects request on SAPUI5 context
	 */
	@publicExtension()
	@finalExtension()
	async requestSideEffects(sideEffects: SideEffectsType, context: Context, groupId?: string, fnGetTargets?: Function): Promise<unknown> {
		let targets: SideEffectsTarget[], triggerAction;
		if (fnGetTargets) {
			const targetsAndActionData = await fnGetTargets(sideEffects);
			targets = targetsAndActionData["aTargets"];
			triggerAction = targetsAndActionData["TriggerAction"];
		} else {
			targets = [...(sideEffects.targetEntities ?? []), ...(sideEffects.targetProperties ?? [])];
			triggerAction = (sideEffects as ODataSideEffectsType).triggerAction;
		}
		if (triggerAction) {
			this._sideEffectsService.executeAction(triggerAction, context, groupId);
		}

		if (targets.length) {
			return this._sideEffectsService.requestSideEffects(targets, context, groupId).catch((error: unknown) => {
				this.registerFailedSideEffects(sideEffects, context);
				throw error;
			});
		}
	}

	/**
	 * Gets failed SideEffects.
	 *
	 * @function
	 * @name getRegisteredFailedRequests
	 * @returns Registered SideEffects requests that have failed
	 */
	@publicExtension()
	@finalExtension()
	public getRegisteredFailedRequests(): FailedSideEffectDictionary {
		return this._registeredFailedSideEffects;
	}

	/**
	 * Adds SideEffects to the queue of the failed SideEffects
	 * The SideEffects are retriggered on the next change on the same context.
	 *
	 * @function
	 * @name registerFailedSideEffects
	 * @param sideEffects SideEffects that need to be retriggered
	 * @param context Context where SideEffects have failed
	 */
	@privateExtension()
	@finalExtension()
	registerFailedSideEffects(sideEffects: SideEffectsType, context: Context): void {
		const contextPath = context.getPath();
		this._registeredFailedSideEffects[contextPath] = this._registeredFailedSideEffects[contextPath] ?? [];
		const isNotAlreadyListed = this._registeredFailedSideEffects[contextPath].every(
			(mFailedSideEffects) => sideEffects.fullyQualifiedName !== mFailedSideEffects.fullyQualifiedName
		);
		if (isNotAlreadyListed) {
			this._registeredFailedSideEffects[contextPath].push(sideEffects);
		}
	}

	/**
	 * Deletes SideEffects to the queue of the failed SideEffects for a context.
	 *
	 * @function
	 * @name unregisterFailedSideEffectsForAContext
	 * @param contextPath Context path where SideEffects have failed
	 */
	@publicExtension()
	@finalExtension()
	unregisterFailedSideEffectsForAContext(contextPath: string) {
		delete this._registeredFailedSideEffects[contextPath];
	}

	/**
	 * Deletes SideEffects to the queue of the failed SideEffects.
	 *
	 * @function
	 * @name unregisterFailedSideEffects
	 * @param sideEffectsFullyQualifiedName SideEffects that need to be retriggered
	 * @param context Context where SideEffects have failed
	 */
	@privateExtension()
	@finalExtension()
	unregisterFailedSideEffects(sideEffectsFullyQualifiedName: string, context: Context): void {
		const contextPath = context.getPath();
		if (this._registeredFailedSideEffects[contextPath]?.length) {
			this._registeredFailedSideEffects[contextPath] = this._registeredFailedSideEffects[contextPath].filter(
				(sideEffects) => sideEffects.fullyQualifiedName !== sideEffectsFullyQualifiedName
			);
		}
	}

	/**
	 * Adds SideEffects to the queue of a FieldGroup
	 * The SideEffects are triggered when event related to the field group change is fired.
	 *
	 * @function
	 * @name registerFieldGroupSideEffects
	 * @param sideEffectsProperties SideEffects properties
	 * @param fieldGroupPreRequisite Promise to fullfil before executing the SideEffects
	 */
	@privateExtension()
	@finalExtension()
	registerFieldGroupSideEffects(sideEffectsProperties: FieldSideEffectPropertyType, fieldGroupPreRequisite?: Promise<unknown>) {
		const id = this._getFieldGroupIndex(sideEffectsProperties.name, sideEffectsProperties.context);
		if (!this._registeredFieldGroupMap[id]) {
			this._registeredFieldGroupMap[id] = {
				promise: fieldGroupPreRequisite ?? Promise.resolve(),
				sideEffectProperty: sideEffectsProperties
			};
		}
	}

	/**
	 * Deletes SideEffects to the queue of a FieldGroup.
	 *
	 * @function
	 * @name unregisterFieldGroupSideEffects
	 * @param sideEffectsProperties SideEffects properties
	 */
	@privateExtension()
	@finalExtension()
	unregisterFieldGroupSideEffects(sideEffectsProperties: FieldSideEffectPropertyType) {
		const { context, name } = sideEffectsProperties;
		const id = this._getFieldGroupIndex(name, context);
		delete this._registeredFieldGroupMap[id];
	}

	/**
	 * Gets the registered SideEffects into the queue for a field group id.
	 *
	 * @function
	 * @name getRegisteredSideEffectsForFieldGroup
	 * @param fieldGroupId Field group id
	 * @returns Array of registered SideEffects and their promise
	 */
	@publicExtension()
	@finalExtension()
	getRegisteredSideEffectsForFieldGroup(fieldGroupId: string): FieldGroupSideEffectType[] {
		const sideEffects = [];
		for (const registryIndex of Object.keys(this._registeredFieldGroupMap)) {
			if (registryIndex.startsWith(`${fieldGroupId}_`)) {
				sideEffects.push(this._registeredFieldGroupMap[registryIndex]);
			}
		}
		return sideEffects;
	}

	/**
	 * Gets a status index.
	 *
	 * @function
	 * @name _getFieldGroupIndex
	 * @param fieldGroupId The field group id
	 * @param context SAPUI5 Context
	 * @returns Index
	 */
	private _getFieldGroupIndex(fieldGroupId: string, context: Context): string {
		return `${fieldGroupId}_${context.getPath()}`;
	}

	/**
	 * Gets sideEffects properties from a field group id
	 * The properties are:
	 *  - name
	 *  - sideEffects definition
	 *  - sideEffects entity type
	 *  - immediate sideEffects.
	 *
	 * @function
	 * @name _getSideEffectsPropertyForFieldGroup
	 * @param fieldGroupId
	 * @returns SideEffects properties
	 */
	private _getSideEffectsPropertyForFieldGroup(fieldGroupId: string) {
		/**
		 * string "$$ImmediateRequest" is added to the SideEffects name during templating to know
		 * if this SideEffects must be immediately executed requested (on field change) or must
		 * be deferred (on field group focus out)
		 *
		 */
		const immediate = fieldGroupId.indexOf(IMMEDIATE_REQUEST) !== -1,
			name = fieldGroupId.replace(IMMEDIATE_REQUEST, ""),
			sideEffectParts = name.split("#"),
			sideEffectEntityType = sideEffectParts[0],
			sideEffectPath = `${sideEffectEntityType}@com.sap.vocabularies.Common.v1.SideEffects${
				sideEffectParts.length === 2 ? `#${sideEffectParts[1]}` : ""
			}`,
			sideEffects: ODataSideEffectsType | undefined =
				this._sideEffectsService.getODataEntitySideEffects(sideEffectEntityType)?.[sideEffectPath];
		return { name, immediate, sideEffects, sideEffectEntityType };
	}

	/**
	 * Manages the SideEffects for a field.
	 *
	 * @function
	 * @name _manageSideEffectsFromField
	 * @param field Field control
	 * @param fieldGroupPreRequisite Promise to fullfil before executing deferred SideEffects
	 * @returns Promise related to the requested immediate sideEffects and registered deferred SideEffects
	 */
	private async _manageSideEffectsFromField(field: Control, fieldGroupPreRequisite: Promise<unknown>): Promise<void> {
		const sideEffectsMap = this.getFieldSideEffectsMap(field);
		try {
			const failedSideEffectsPromises: (void | Promise<unknown>)[] = [];
			const sideEffectsPromises = Object.keys(sideEffectsMap).map((sideEffectsName) => {
				const sideEffectsProperties = sideEffectsMap[sideEffectsName];

				if (sideEffectsProperties.immediate === true) {
					// if this SideEffects is recorded as failed SideEffects, need to remove it.
					this.unregisterFailedSideEffects(sideEffectsProperties.sideEffects.fullyQualifiedName, sideEffectsProperties.context);
					return this.requestSideEffects(sideEffectsProperties.sideEffects, sideEffectsProperties.context);
				}
				return this.registerFieldGroupSideEffects(sideEffectsProperties, fieldGroupPreRequisite);
			});

			//Replay failed SideEffects related to the view or Field
			for (const context of [field.getBindingContext(), this._view.getBindingContext()]) {
				if (context) {
					const contextPath = context.getPath();
					const failedSideEffects = this._registeredFailedSideEffects[contextPath] ?? [];
					this.unregisterFailedSideEffectsForAContext(contextPath);
					for (const failedSideEffect of failedSideEffects) {
						failedSideEffectsPromises.push(this.requestSideEffects(failedSideEffect, context as Context));
					}
				}
			}

			await Promise.all(sideEffectsPromises.concat(failedSideEffectsPromises));
		} catch (e) {
			Log.debug(`Error while managing Field SideEffects`, e as string);
		}
	}

	/**
	 * Requests the SideEffects for a fieldGroup.
	 *
	 * @function
	 * @name _requestFieldGroupSideEffects
	 * @param fieldGroupSideEffects Field group sideEffects with its promise
	 * @returns Promise returning true if the SideEffects have been successfully executed
	 */
	private async _requestFieldGroupSideEffects(fieldGroupSideEffects: FieldGroupSideEffectType): Promise<void> {
		this.unregisterFieldGroupSideEffects(fieldGroupSideEffects.sideEffectProperty);
		try {
			await fieldGroupSideEffects.promise;
		} catch (e) {
			Log.debug(`Error while processing FieldGroup SideEffects`, e as string);
			return;
		}
		try {
			const { sideEffects, context, name } = fieldGroupSideEffects.sideEffectProperty;
			if (this.isFieldGroupValid(name, context)) {
				await this.requestSideEffects(sideEffects, context);
			}
		} catch (e) {
			Log.debug(`Error while executing FieldGroup SideEffects`, e as string);
		}
	}

	/**
	 * Saves the validation status of properties related to a field control.
	 *
	 * @param field The field control
	 * @param success Status of the field validation
	 */
	private _saveFieldPropertiesStatus(field: Control, success: boolean): void {
		const sideEffectsMap = this.getFieldSideEffectsMap(field);
		Object.keys(sideEffectsMap).forEach((key) => {
			const { name, immediate, context } = sideEffectsMap[key];
			if (!immediate) {
				const id = this._getFieldGroupIndex(name, context);
				if (success) {
					delete this._fieldGroupInvalidity[id]?.[field.getId()];
				} else {
					this._fieldGroupInvalidity[id] = {
						...this._fieldGroupInvalidity[id],
						...{ [field.getId()]: true }
					};
				}
			}
		});
	}
}

export default SideEffectsControllerExtension;
