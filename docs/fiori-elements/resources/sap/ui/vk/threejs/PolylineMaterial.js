/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)

        (c) Copyright 2009-2015 SAP SE. All rights reserved
    
 */
sap.ui.define(["../thirdparty/three"],function(e){"use strict";var t={lineColor:{value:new e.Color(1,1,1)},linewidth:{value:1},resolution:{value:new e.Vector2(1,1)},dashScale:{value:1},dashPeriod:{value:new e.Vector3(1,1,1)},dashAtlas:{value:null},lineLength:{value:1e5}};var i=e.UniformsUtils.merge([e.UniformsLib.common,e.UniformsLib.fog,t]);var n=["#include <common>","#include <color_pars_vertex>","#include <fog_pars_vertex>","#include <logdepthbuf_pars_vertex>","#include <clipping_planes_pars_vertex>","","uniform float linewidth;","uniform vec2 resolution;","","attribute vec3 instanceStart;","attribute vec3 instanceEnd;","","varying vec2 vTC;","","#if defined(USE_DASH) || TRIM_STYLE","attribute vec2 instanceDistance;","varying float vLineDistance;","#endif","","void trimSegment(const in vec4 start, inout vec4 end) {","\t// trim end segment so it terminates between the camera plane and the near plane","","\t// conservative estimate of the near plane","\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column","\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column","\tfloat nearEstimate = -0.5 * b / a;","","\tfloat t = (nearEstimate - start.z) / (end.z - start.z);","","\tend.xyz = mix(start.xyz, end.xyz, t);","}","","void main() {","\tvTC = uv * linewidth;","","\t// camera space","\tvec4 start = modelViewMatrix * vec4(instanceStart, 1.0);","\tvec4 end = modelViewMatrix * vec4(instanceEnd, 1.0);","","\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane","\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space","\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly","\t// perhaps there is a more elegant solution -- WestLangley","","\tbool perspective = (projectionMatrix[ 2 ][ 3 ] == -1.0); // 4th entry in the 3rd column","\tif (perspective) {","\t\tif (start.z < 0.0 && end.z >= 0.0) {","\t\t\ttrimSegment(start, end);","\t\t} else if (end.z < 0.0 && start.z >= 0.0) {","\t\t\ttrimSegment(end, start);","\t\t}","\t}","","\t// clip space","\tvec4 clipStart = projectionMatrix * start;","\tvec4 clipEnd = projectionMatrix * end;","","\t// ndc space","\tvec2 ndcStart = clipStart.xy / clipStart.w;","\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;","","\t// direction","\tvec2 dir = (ndcEnd - ndcStart) * resolution;","\tfloat l = length(dir);","\tdir = normalize(dir);","","\t// perpendicular to dir","\tvec2 offset = vec2(dir.y, -dir.x) * position.x;","","#if defined(USE_DASH) || TRIM_STYLE","\tvLineDistance = mix(instanceDistance.x, instanceDistance.y, position.y);","#endif","","\t// endcaps","\tif ( position.y < 0.0 ) {","\t\toffset -= dir;","#if defined(USE_DASH)","\t\tvLineDistance = mix(instanceDistance.x, instanceDistance.y, position.y * linewidth / l);","#endif","\t} else if ( position.y > 1.0 ) {","\t\toffset += dir;","#if defined(USE_DASH)","\t\tvLineDistance = mix(instanceDistance.x, instanceDistance.y, 1.0 + (position.y - 1.0) * linewidth / l);","#endif","\t}","","\t// select end","\tvec4 clip = (position.y < 0.5) ? clipStart : clipEnd;","\tclip /= clip.w; // remove perspective correction","","\tclip.xy += offset * (linewidth / resolution);","","\tgl_Position = clip;","","\tvec4 mvPosition = (position.y < 0.5) ? start : end; // this is an approximation","","#include <logdepthbuf_vertex>","#include <clipping_planes_vertex>","#include <fog_vertex>","}"].join("\n");var a=["uniform vec3 diffuse;","uniform vec3 lineColor;","uniform float opacity;","uniform float linewidth;","","#ifdef USE_DASH","uniform float dashScale;","uniform vec3 dashPeriod;","uniform sampler2D dashAtlas;","#endif","","#if (TRIM_STYLE & 2)","uniform float lineLength;","#endif","","varying float vLineDistance;","","#include <common>","#include <color_pars_fragment>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","#include <clipping_planes_pars_fragment>","","varying vec2 vTC;","","void main() {","","#include <clipping_planes_fragment>","","\tvec4 diffuseColor = vec4(diffuse * lineColor, opacity);","","\tvec2 uv = abs(vTC);","\tdiffuseColor.a *= clamp(linewidth + 0.5 - uv.y, 0.0, 1.0); // line antialiasing","","#if (TRIM_STYLE & 1)","\tif (vLineDistance < 0.0)","\t\tdiscard;","#endif","","#if (TRIM_STYLE & 2)","\tif (vLineDistance > lineLength)","\t\tdiscard;","#endif","","\tif (uv.x > linewidth) { // apply segment cap","#if (SEGMENT_CAP_STYLE == 1) // round cap","\t\tvec2 delta = vec2(uv.y, uv.x - linewidth);","\t\tdiffuseColor.a *= clamp(linewidth - length(delta), 0.0, 1.0);","#else","\t\tdiffuseColor.a *= clamp(linewidth + 1.0 - uv.x, 0.0, 1.0);","#endif","\t}","","#include <logdepthbuf_fragment>","#include <color_fragment>","","#ifdef USE_DASH","\tfloat x = fract(vLineDistance * dashPeriod.y / dashScale);","\tvec4 dash = texture2D(dashAtlas, vec2(x * dashPeriod.z, 0.5));","\tdash.zw *= 255.0;","\tx *= dashPeriod.x;","\tdash.zw = vec2(dash.z - x, x - dash.w);","\tx = min(dash.z, dash.w) * dashScale;","#if (DASH_CAP_STYLE == 1) // round cap","\tvec2 delta = vec2(x * 2.0, uv.y);","\tdiffuseColor.a *= max(step(x / linewidth, 0.0), clamp(linewidth + 0.5 - length(delta), 0.0, 1.0));","#else // no cap","\tdiffuseColor.a *= clamp(0.5 - x, 0.0, 1.0);","#endif","#endif","","\tgl_FragColor = diffuseColor;","","#include <premultiplied_alpha_fragment>","#include <tonemapping_fragment>","#include <encodings_fragment>","#include <fog_fragment>","}"].join("\n");function r(t){var s=new e.ShaderMaterial({type:"PolylineMaterial",uniforms:e.UniformsUtils.clone(i),vertexShader:n,fragmentShader:a});Object.setPrototypeOf(s,r.prototype);s.defines.DASH_CAP_STYLE=0;s.defines.SEGMENT_CAP_STYLE=0;s.defines.TRIM_STYLE=0;s._dashPattern=[];Object.defineProperties(s,{color:{enumerable:true,get:function(){return this.uniforms.diffuse.value},set:function(e){this.uniforms.diffuse.value=e}},lineColor:{enumerable:true,get:function(){return this.uniforms.lineColor.value},set:function(e){this.uniforms.lineColor.value=e}},linewidth:{enumerable:true,get:function(){return this.uniforms.linewidth.value},set:function(e){this.uniforms.linewidth.value=e}},dashCapStyle:{enumerable:true,get:function(){return this.defines.DASH_CAP_STYLE},set:function(e){this.defines.DASH_CAP_STYLE=e}},segmentCapStyle:{enumerable:true,get:function(){return this.defines.SEGMENT_CAP_STYLE},set:function(e){this.defines.SEGMENT_CAP_STYLE=e}},trimStyle:{enumerable:true,get:function(){return this.defines.TRIM_STYLE},set:function(e){this.defines.TRIM_STYLE=e}},dashScale:{enumerable:true,get:function(){return this.uniforms.dashScale.value},set:function(e){this.uniforms.dashScale.value=e}},dashPattern:{enumerable:true,get:function(){return this._dashPattern},set:function(e){this._dashPattern=e;this._updateDashAtlas()}},resolution:{enumerable:true,get:function(){return this.uniforms.resolution.value},set:function(e){this.uniforms.resolution.value.copy(e)}},lineLength:{enumerable:true,get:function(){return this.uniforms.lineLength.value},set:function(e){this.uniforms.lineLength.value=e}}});s.setValues(t);return s}r.prototype=Object.create(e.ShaderMaterial.prototype);r.prototype.constructor=r;r.prototype.isLineMaterial=true;r.prototype._updateDashAtlas=function(){if(!this._dashPattern.length){delete this.defines.USE_DASH;this.uniforms.dashAtlas.value=null;this.needsUpdate=true;return}var t=Array.from(this._dashPattern);if(t.length&1){t=t.concat(t)}var i=t.reduce(function(e,t){return e+Math.ceil(t)});var n=e.MathUtils.ceilPowerOfTwo(i);this.uniforms.dashPeriod.value.set(i,1/i,i/n);var a=new Uint8Array(n*4);for(var r=0,s=0,o=0;r<t.length;r++){var l=t[r];var d=r&1?s+l:s;var c=r&1?s:s+l;var u=r&1?0:255;while(l-- >0){a[o++]=u;a[o++]=0;a[o++]=d;a[o++]=c;s++}}var f=new e.DataTexture(a,n,1,e.RGBAFormat,e.UnsignedByteType,e.UVMapping,e.ClampToEdgeWrapping,e.ClampToEdgeWrapping,e.NearestFilter,e.NearestFilter);f.needsUpdate=true;this.defines.USE_DASH="";this.uniforms.dashAtlas.value=f;this.needsUpdate=true};r.prototype.copy=function(t){e.ShaderMaterial.prototype.copy.call(this,t);this.color.copy(t.color);this.lineColor.copy(t.lineColor);this.linewidth=t.linewidth;this.dashCapStyle=t.dashCapStyle;this.segmentCapStyle=t.segmentCapStyle;this.trimStyle=t.trimStyle;this.dashPattern=t.dashPattern;this.resolution=t.resolution;this.lineLength=t.lineLength;return this};return r});